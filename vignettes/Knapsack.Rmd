---
title: "Vignette for 732A94 Lab6 Knapsack assignment Group 14"
author: "Raymond Sseguya, Martin Smelik, Vinay"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The Knapsack Problem}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The follwing 3 alogorithms based on different computational complexity were implemented to find the solution for the Knapsack problem
1. Brute force search
2. Dynamic programming
3. Greedy heuristic

# Generation of Knapsack objects.

```{r setup, include=FALSE, eval=TRUE, message=FALSE, warning=FALSE}

set.seed(42)
n <- 2000
knapsack_objects <-
  data.frame(
    w=sample(1:4000, size = n, replace = TRUE),
    v=runif(n = n, 0, 10000)
  )
save(knapsack_objects, file="data/knapsack_objects.RData")

```

# Algorithm 1: Brute force search (Computational complexity: O(2^n))

```{r setup, include=FALSE, eval=TRUE, message=FALSE, warning=FALSE}

brute_force_knapsack <- function(x, W)
{
  stopifnot(is.data.frame(x) == T)
  stopifnot(ncol(x)==2)
  stopifnot(colnames(x)== list("w","v"))
  stopifnot(all(x$v>0))
  stopifnot(all(x$w>0))
  stopifnot(W>=0)
  ideal_value <- 0
  x <- x[which(x$w < W), ]
  n = nrow(x)
  for (i in 1:(2^n-1)) 
  {
    permutation <- intToBits(i)
    weight <- sum(as.numeric(permutation[1:n])*x$w)
    value <- sum(as.numeric(permutation[1:n])*x$v)
    if (ideal_value<value && weight < W)
    {
      ideal_value <- value
      elements <- as.numeric(permutation[1:n])*x$label
    }
  }
  return(list(value=round(ideal_value,0), elements=which(elements>0)))
}

```

We create a function called brute_force_knapsack with argument x which is a matrix containing 2 rows, weights and its corresponding values. Argument W is the Knapsack capacity. The cumulative value of all possible combinations are computed one after the other and the best combination of elements, i.e. the one with maximum cumulative value whose cumulative weights is within the specified Knapsack weight capacity, are filled in the Knapsack. The function returns the cumulative value of the corresponding elements filled in the knapsack and the element(id) itself.

Time taken to run the algoritm for n= 16 objects : 

```{r message=FALSE, warning=FALSE}
system.time(brute_force_knapsack(x = knapsack_objects[1:16,], W = 2000))

system.time(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500))

```


# Algorithm 2: Dynamic programming (Computational complexity: O(Wn))

```{r setup, include=FALSE, eval=TRUE, message=FALSE, warning=FALSE}

knapsack_dynamic <- function(x,W)
{
  stopifnot(is.data.frame(x) == T)
  stopifnot(ncol(x)==2)
  stopifnot(colnames(x)== list("w","v"))
  stopifnot(all(x$v>0))
  stopifnot(all(x$w>0))
  stopifnot(W>=0)
  n = nrow(x)
  x$ord <- 1:n
  x <- x[which(x$w < W), ]
  n = nrow(x)
  m <- matrix(0, nrow=n, ncol=W+1)
  path <- as.data.frame(matrix(0,nrow = n, ncol = W+1))

  for(i in 1:n)
  {
    for(j in 1:W+1)
    {
      if (x$w[[i]] >j-1 && i==1) {path[[1,j]] <- list(0)}
      else if (x$w[[i]] >j-1) 
      {
        m[[i,j]] <- m[[i-1,j]]
        path[[i,j]] <- path[[i-1,j]]
      }
      else 
      {
        if(i==1) 
        {
          m[[i,j]] <- x$v[[i]]
          path[[i,j]] <- list(x$ord[[i]])
        }
        else
        {
          m[[i,j]] <- max(m[[i-1,j]],m[[i-1,j-x$w[[i]]]] + x$v[[i]])
          if(m[[i-1,j]] < m[[i-1,j-x$w[[i]]]] + x$v[[i]])
            { path[[i,j]] <- rlist::list.append(path[[i-1,j-x$w[[i]]]],x$ord[[i]]) }
          else
            path[[i,j]] <- path[[i-1,j]]
        }
      }
    }
  }
  elements <- path[[n,W+1]]
  elements = elements[which(elements>0)]
  return(list(value= round(m[[n,W+1]],0), elements=unlist(elements, use.names = FALSE) ))
}

```

Tabular method is used to solve the problem using Dynamic programming method. 

Time taken to run the algoritm for n= 500 objects :

```{r message=FALSE, warning=FALSE, eval=FALSE}
system.time(knapsack_dynamic(x = knapsack_objects[1:500,], W = 2000))

system.time(knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500))

```


# Algorithm 3: Greedy heuristic (Computational complexity: O(nlogn))

```{r setup, include=FALSE, eval=TRUE, message=FALSE, warning=FALSE}

greedy_knapsack <- function(x,W, fast = FALSE)
{
  stopifnot(is.data.frame(x) == T)
  stopifnot(ncol(x)==2)
  stopifnot(colnames(x)== list("w","v"))
  stopifnot(all(x$v>0))
  stopifnot(all(x$w>0))
  stopifnot(W>=0)
  n = nrow(x)
  x$ord <- 1:n
  x <- x[which(x$w < W), ]
  n = nrow(x)
  
  if(fast == TRUE)
  {
    Rcpp::sourceCpp("src/division.cpp")
    z <- divisionCpp(x$v, x$w, n)
    
  x$z <- z
  }
  else
  {
    
#   cppFunction('double sumC(NumericVector x) {
#   int n = x.size();
#   double total = 0;
#   for(int i = 0; i < n; ++i) {
#     total += x[i];
#   }
#   return total;
# }')
  
  x$z <- x$v/x$w
  }
  
  
  
  x <-x [with(x, order(-z)),]
  i<- 1
  weight <- 0
  value <- 0
  elements <- list()
  while (i<n+1 && weight + x$w[[i]]<W  )
    {
      weight <- weight + x$w[[i]] 
      value <- value + x$v[[i]]
      elements[[i]] <- x$ord[[i]]
      i<- i+1
    }
  
  return(list(value=round(value,0), elements=unlist(elements, use.names = FALSE) ))
}

```

The ratios of each value to its corresponding weights are considered to fill up the knapsack. The elements with the higher ratio is put into the knapsack first. 

Time taken to run the algoritm for n= 1000000 objects :

```{r message=FALSE, warning=FALSE, eval=FALSE}
system.time(greedy_knapsack(x = knapsack_objects[1: 1000000,], W = 2000), fast=FALSE)

system.time(greedy_knapsack(x = knapsack_objects[1: 1000000,], W = 3500), fast=FALSE)

```

# 1.1.5 Implement a test suite



# 1.1.6 Profile code



# 1.1.7 (*) Implentation in Rcpp



# 1.2 (*) Profiling and improving existing API package
